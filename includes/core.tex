\section{IPC}
\acrfull{ipc} predstavuje súbor mechanizmov určených na komunikáciu a správu dát medzi viacerými procesmi. Operačný systém Linux obsahuje niekoľko takýchto mechanizmov, medzi najhlavnejšie patria:
\begin{itemize}
\item Signály
\item Rúry
\item Fronty správ
\item Semafory
\item Zdieľaná pamäť
\item Sokety
\end{itemize}
V nasledujúcich odsekoch si bližšie popíšeme tieto mechanizmy.
\subsection{Signály}
Ide o jeden z najstarších \acrshort{ipc} mechanizmov používaný v Unix systémoch. Signál je asynchrónne upozornenie zaslané procesu alebo konkrétnemu vláknu v rámci toho istého procesu, za účelom upozornenia na udalosť, ktorá sa vyskytla. V momente keď sa signál odošle, operačný systém preruší vykonávanie procesu, ktorý má byť signalizovaný a v tomto procese sa vykoná obslúženie signálu.

Je potrebné si uvedomiť že \textbf{signály nie sú} to isté ako \textbf{prerušenia}. Rozdiel medzi signálom a prerušením je, že prerušenie je vyvolané procesorom a signál je vyvolaný z jadra systému.
Signál je možné vyvolať systémovým volaním \textbf{kill}. Toto systémové volanie má dva parametre:
\begin{itemize}
\item \textit{pid} - identifikátor procesu, ktorý má byť signalizovaný
\item \textit{sig} - typ signálu
\end{itemize}
Podporované typy je možné zistiť pomocou príkazu \textit{kill -l} alebo v súbore \textit{/include/linux/signal.h}.

V prípade že je definovaná obslužná funkcia, táto funkcia sa vykoná, v opačnom prípade je použitá štandardná obsluha signálu. Obslužnú funkciu je možné definovať pomocou funkcie \textbf{signal}, avšak správanie tejto funkcie môže byť rozdielne vzhľadom na platformu. Preto sa odporúča používať funkciu \textbf{sigaction}, ktorá bola definovaná v štandarde \textbf{POSIX.1}. Toto systémové volanie má parametere:
\begin{itemize}
\item \textit{signum} - typ signálu, ktorý chceme obslúžiť
\item \textit{act} - definuje akciu, ktorá sa má vykonať pri obsluhe signálu
\item \textit{oldact} - definuje starú obsluhu signálu
\end{itemize}

\textbf{Signály} je možné použiť pre komunikáciu ako aj synchronizáciu avšak ide o veľmi slabý nástroj pre tieto potreby.\footnote{\url{http://man7.org/conf/lca2013/IPC_Overview-LCA-2013-printable.pdf}}
\subsection{Rúry}
Rúry predstavujú jednosmerný tok dát medzi procesmi: všetky dáta zapísané procesom do rúry sú jadrom   presmerované do iného procesu, ktorý z nej môže čítať. Poznáme 2 druhy rúr:
\begin{itemize}
\item Anonymné rúry - žiadny objekt v súborovom strome
\item Pomenované rúry - objekt v súborovom strome
\end{itemize}
\subsubsection{Anonymné rúry}
\textbf{Anonymné rúry} je možné vytvoriť pomocou systémového volania \textbf{pipe}, alebo taktiež pomocou znaku \textbf{|} vo väčšine \textit{Unix} príkazových riadkoch.Systémové volanie \textbf{pipe} obsahuje jeden parameter, ktorým je pole \textit{pipefd} o veľkosti 2. Toto pole obsahuje po návrate z funkcie súborové deskriptory. Tieto dva súborové deskriptory predstavujú konce rúry, \textit{pipefd[0]} je čítací koniec rúry a \textit{pipefd[1]} je zapisovací koniec rúry. Tieto súborové deskriptory je následne možné použiť na zapisovanie a čítanie pomocou systémových volaní \textit{write}\footnote{\url{http://man7.org/linux/man-pages/man2/write.2.html}} a \textit{read}\footnote{\url{http://man7.org/linux/man-pages/man2/read.2.html}}. Tieto operácie sú blokujúce v dvoch prípadoch:
\begin{itemize}
\item write - rúra je plná
\item read - rúra je prázdna
\end{itemize}
Niektoré \textit{Unix} systémy ako napríklad \textit{System V Release 4}, implementuje \textbf{full-duplex} rúry, teda rúry, pri ktorých oba konce rúry(súborové deskriptory) je možné použiť ako na zapisovanie tak aj na čítanie. Avšak štandard \textbf{\acrshort{posix}} definuje iba \textbf{half-duplex} rúry, pričom každý proces musí zatvoriť jeden deskriptor pred použitím druhého.

Takto vytvorená rúra umožňuje komunikáciu medzi rodičovským procesom a jeho potomkami. Avšak je potrebné zabezpečiť aby procesy, ktoré medzi sebou chcú komunikovať zdieľali rovnaké súborové deskriptory. Toto je možné jednoducho dosiahnuť tak, že sa rúra vytvorí pred vytvorením detského procesu(\textit{fork}). Zjednodušený pseudokód môžeme vidieť tu \ref{lst:pipe-c} spolu s ilustračný obrázkom \ref{pipeflow}.
\begin{lstlisting}[
  caption={Použite anonymných rúr},
  label={lst:pipe-c},
  language=c
]
int filedes[2];

pipe(filedes);

child_pid = fork();
if (child_pid == 0) {
	close(filedes[1]);
} else {
	close(filedes[1]);
}
\end{lstlisting}
\begin{figure}[!htbp]
  \centering
  \includegraphics[width=5cm]{img/rura.png}
  \caption{Tok dát medzi procesmi.}
  \label{pipeflow}
\end{figure}

Nevýhodou tohto systémového volania je absencia v súborovom strome a teda nie je možné využiť tento \acrshort{ipc} mechanizmus na komunikáciu medzi ľubovoľnými dvoma alebo viacerými procesmi.
\subsubsection{Pomenované rúry}
Pomenované rúry taktiež nazývané aj \textbf{\acrshort{fifo}} na rozdiel od anonymných rúr máju meno v súborovom systéme. Jednou z možností ako vytvoriť tento typ rúry je pomocou funkcie \textbf{mkfifo}, ktorá je definovaná v štandarde \acrshort{posix}. Táto funkcia v svojej implementácií volá systémové volanie \textit{mknod} s príznakom, ktorý definuje že ide o pomenovanú rúru. Funkcia \textbf{mkfifo} má 2 parametre:
\begin{itemize}
\item \textit{pathname} - názov rúry
\item \textit{mode} - práva súboru 
\end{itemize}
Návratová hodnota funkcie je 0 v prípade úspechu a v prípade chyby je návratová hodnota -1. Takto vytvorenú rúru je možné rovnako ako anonymné rúry obsluhovať pomocou systémových volaní \textit{read} a \textit{write}.

\subsection{Fronty správ}
Fronty správ si najlepšie môžme predstaviť ako zreťazený zoznam v adresnom priestore jadra. Správy môžu byť odosielané do fronty v poradí a následne načítané z fronty pomocou niekoľko rôznych spôsobov. Každá fronta správ je jednoznačne identifikovaná pomocou \acrshort{ipc} identifikátora. Pre lepšie pochopenie tohto konceptu si popíšeme 3 hlavné štruktúry, ktoré zabezpečujú fungovanie fronty správ v jadre Linuxu.
\subsubsection{Štruktúry semaforov}
Štruktúra \texttt{msgbuf} (definovaná v \url{linux/msg.h}) predstavuje predlohu ako by mala vyzerať správa, ktorú budeme posielať. Táto predloha obsahuje dve položky: 
\begin{itemize}
\item long \textbf{mtype} - umožňuje určiť o aký typ správy ide, napríklad \textit{chybová správa}, \textit{normálna správa} a podobne, možností je nekonečno
\item char \textbf{mtext}[1] - samotné dáta správy, túto položku je možné ľubovoľne rozšíriť, ako napríklad v ukážke kódu \ref{lst:msgbuf}, avšak s limitom, ktorý je maximálna dĺžka správy \textit{\textbf{MSGMAX}}=8192\footnote{Táto veľkosť je definovaná v \url{linux/msg.h} a môže sa líšiť od verzie jadra. Túto hodnotu je taktiež možné zistiť pomocou príkazu \textit{ipcs -l}.}
\end{itemize}

\begin{lstlisting}[
  caption={Príklad vlastnej štruktúry správy},
  label={lst:msgbuf},
  language=c
]
struct message {
    long type;
    struct my_special_struct data;    
} msg;
\end{lstlisting}

Každá správa je rozdelená na stránky, ktoré sú dynamicky alokované v pamäti. Veľkosť tejto stránky je závislí od architektúry a zisťuje sa nasledovne \textit{sysconf(\_SC\_PAGESIZE)}. Štruktúra \textbf{\textit{msg\_msg}}, ktorú môžeme vidieť tu \ref{lst:msgmsg}, predstavuje hlavičku každej správy pričom sa inštancie tejto štruktúry nachádzajú v zreťazenom zozname, ktorý je definovaný položkou \textit{m\_list}. V prípade že dĺžka správy je menšia ako $$ \text{PAGE\_SIZE} - \text{sizeof(struct msg\_msg)} $$ celý obsah správy sa nachádza v pamäťovej oblasti za štruktúrou \textit{msg\_msg}. V opačnom prípade sa prvá časť správy nachádza na rovnakom mieste a ostatné stránky sa nachádzajú v pamäťovej oblasti, na ktorú ukazuje ukazovateľ \textit{next}. Tento ukazovateľ odkazuje na štruktúru \textit{msg\_msgseg} pozri \ref{lst:msgmsgseg}, ktorá obsahuje ukazovateľ \textit{next} na ďalšiu stránku, pričom v pamäťovej oblasti za touto štruktúrou sa nachádzajú dáta aktuálnej stránky.
\begin{lstlisting}[
  caption={Štruktúra msg\_msg},
  label={lst:msgmsg},
  language=c
]
struct msg_msg {
	struct list_head m_list;
	long m_type;
	size_t m_ts;
	struct msg_msgseg *next;
	void *security;
	/* obsah prvej stránky */
};
\end{lstlisting}

\begin{lstlisting}[
  caption={Štruktúra msg\_msgseg},
  label={lst:msgmsgseg},
  language=c
]
struct msg_msgseg {
	struct msg_msgseg *next;
	/* obsah stránky */
};
\end{lstlisting}

Poslednou štruktúrou, ktorá sa nachádza najvyššie v hierarchií týchto štruktúr je \texttt{\textbf{msq\_queue}} a jej deklaráciu môžete vidieť na ukážke kódu \ref{lst:msgmsgseg}. Najdôležitejšou položkou tejto štruktúry je položka\texttt{q\_messages}, ktorá predstavuje prvý element zreťazeného zoznamu všetkých správ vo fronte. Ďalšie zreťazené zoznamy, ktoré sa tu nachádzajú sú \texttt{q\_receivers} a \texttt{q\_senders}, ktoré obsahujú zreťazené zoznamy procesov, ktoré posielajú správy a procesov, ktoré prijímajú správy. Zaujímavou položkou z pohľadu bezpečnosti je položka \texttt{q\_perm}, ktorá obsahuje inštanciu štruktúry \texttt{\textbf{kern\_ipc\_perm}}. Túto štruktúru si popíšeme v kapitole \ref{kernipcperm}.
\begin{lstlisting}[
  caption={Štruktúra msq\_queue},
  label={lst:msgmsgseg},
  language=c
]
struct msg_queue {
	struct kern_ipc_perm q_perm;
	/* meta dáta */		
	struct list_head q_messages;
	struct list_head q_receivers;
	struct list_head q_senders;
} __randomize_layout;
\end{lstlisting}
\subsubsection{Štruktúra kern\_ipc\_perm} \label{kernipcperm}
Štruktúra \texttt{kern\_ipc\_perm} sa nenachádza len pri fronte správ ale taktiež aj pri semaforoch a zdieľanej pamäti. Táto štruktúra predstavuje sadu meta dát o konkrétnom \acrshort{ipc} objekte a jej položky spolu s typmi môžeme vidieť na ukážke kódu \ref{lst:kernipcperm}. Vyznám týchto položiek je nasledovný:
\begin{itemize}
\item lock - uzamykací mechanizmus pre ochranu \acrshort{ipc} objektu
\item deleted - príznak, či bol zdroj uvoľnený
\item id
\item key - jednoznačný identifikátor, v rámci konkrétneho typu objektu, to znamená, že jedna inštancia semafora, zdieľanej pamäte alebo fronty správ môže mať rovnaký identifikátor
\item uid - ID používateľa, ktorý vlastní \acrshort{ipc} objekt
\item gid - ID skupiny, ktorá vlastní \acrshort{ipc} objekt
\item cuid - ID používateľa, ktorý vytvoril \acrshort{ipc} objekt
\item cgid - ID skupiny, ktorá vytvorila \acrshort{ipc} objekt
\item mode - bitová maska oprávnení
\item seq - sekvenčné číslo, používané sa na vytvorenie nového identifikátora pre \acrshort{ipc} objekt
\item security - ukazovateľ na štruktúru, ktorú vytvára zvolené bezpečnostné riešenie v jadre Linuxu
\item khtnode
\item rcu - \acrshort{rcu} synchronizačný mechanizmus
\item refcount - počítadlo použití \acrshort{ipc} objektu
\end{itemize}
\subsubsection{Požívanie fronty správ} \label{msguse}
Na vytvorenie fronty správ sa používa systémové volanie \texttt{msgget}. Toto systémové volanie má dva parametre, ktorými sú \texttt{key}(identifikátor objektu) a \texttt{msgflg} príznaky \acrshort{ipc} objektu. Nová fronta je vytvorená v prípadoch, že:
\begin{itemize}
\item \texttt{key} sa rovná \texttt{IPC\_PRIVATE}
\item \texttt{key} nemá ešte priradený žiadny \acrshort{ipc} objekt a \texttt{IPC\_CREATE} príznak je definovaný v parametre \texttt{msglfg}
\end{itemize}
Ak je definovaný príznak \texttt{IPC\_EXCL} spolu s \texttt{IPC\_CREATE} a identifikátor už existuje, volanie funkcie zlyhá s chybovou správou \texttt{EEXIST}, ktorá definuje, že \acrshort{ipc} objekt už existuje. Naopak v prípade, že \texttt{IPC\_EXCL} nie je definované tak návratová hodnota je identifikátor už existujúceho \acrshort{ipc} objektu.

Na posielanie a prijímanie správ z fronty sa používajú systémové volania \texttt{msgsnd} a \texttt{msgrcv}. Funkcia \texttt{msgsnd} má nasledovné parametre:
\begin{itemize}
\item \texttt{msgid} identifikátor fronty získaný z funkcie \texttt{msgget}
\item \texttt{msgp} ukazovateľ na štruktúru, ktorú si používateľ definuje sám a mal by vychádzať zo šablóny ktorú sme si popísali v kapitole \ref{lst:msgbuf}
\item \texttt{msgsz} veľkosť dátovej štruktúry, ktorú chceme prenášať
\item \texttt{msgflg} príznaky, ktoré definujú čo sa má diať v prípade, že je fronta plná
\end{itemize}
Funkcia \texttt{msgrcv}, odstráni správu z frontu a premiestni do pamäte, na ktorý ukazuje parameter funkcie \texttt{msgp}. Ďalšie parametre sú:
\begin{itemize}
\item \texttt{msgsz} maximálnu veľkosť dát v bytoch pre položku \texttt{mtext}, štruktúry, na ktorú ukazuje ukazovateľ \texttt{msgp}
\item \texttt{msgflg} príznaky, ktoré definujú čo sa má diať v prípade, že je fronta prázdna
\item \texttt{msgtyp} číslo, ktoré definuje ktorý typ správy bude ako prvý vybraný z fronty(nemôže byt definovaný príznak \texttt{MSG\_COPY}), v prípade že je definovaný príznak \texttt{MSG\_EXCEPT}, tak sa z fronty vyberá prvá správa z typom odlišným od \texttt{msgtyp}
\end{itemize}
Posledným systémovým volaním tohto mechanizmu je \texttt{msgctl}, ktoré vykonáva kontrolné operácie nad objektom. Funkcia má 3 parametre:
\begin{itemize}
\item \texttt{msgid} identifikátor objektu
\item \texttt{cmd} typ operácie
\item \texttt{buf} ide o štruktúru, ktorá sa v jadre ako aj v manuálových stránkach nachádza v 32 bitovej verzií(viď \ref{lst:msqid}), avšak v jadre sa označuje za zastaralú pričom ju nahrádza 64 bitová verzia(viď \ref{lst:msqid64}), táto štruktúra slúži na prenos meta dát z jadra systému do užívateľského priestoru
\end{itemize}
Typy operácie nad frontami správ sú nasledovné:
\begin{itemize}
\item \texttt{IPC\_STAT} a \texttt{MSG\_STAT} kopíruje informácie z jadra do štruktúry na ktorú ukazuje ukazovateľ \texttt{buf}
\item \texttt{IPC\_SET} nastavuje položky jadra na základe ukazovateľa \texttt{buf}, konkrétne \texttt{msg\_perm.uid}, \texttt{msg\_perm.gid}, \texttt{msg\_qbytes} a posledných 9 bitov \texttt{msg\_perm.mode}
\item \texttt{IPC\_RMID} odstraňuje frontu správ
\item \texttt{IPC\_INFO} a \texttt{MSG\_INFO} získava limity a systémové nastavenia pre fronty správ, dáta sa nachádzajú na adrese ukazovateľa \texttt{buf}, avšak dáta sú v štruktúre typu \texttt{msginfo}(viď \ref{lst:msginfo}) a preto je potrebné pre-typovanie\footnote{\texttt{IPC\_INFO} a \texttt{MSG\_INFO} ako aj \texttt{IPC\_STAT} a \texttt{MSG\_STAT} vracajú mierne odlišné dáta a sú platformovo závislé pre viac info pozri \url{http://man7.org/linux/man-pages/man2/msgctl.2.html}}
\end{itemize}
\subsection{Semafory}
Semafor ako \acrshort{ipc} mechanizmus nepredstavuje nástoj na prenášanie dát ale slúži ako synchronizačný mechanizmus na ochranu zdieľaných zdrojov pri viac procesovom alebo viac vláknovom vykonávaný programu. Všeobecný semafor si môžme predstaviť ako počítadlo, ktoré je možné atomický upravovať. Semafor zvyčajne implementuje dve základné funkcie, ktoré slúžia na zvýšenie(\texttt{signal}) a zníženie(\texttt{wait}) tohto počítadla. Napríklad ak proces 1 chce vstúpiť do chránenej oblasti(pristúpiť k zdieľaným zdrojom) zníži počítadlo semaforu. Proces 2, ktorý taktiež bude chcieť pristúpiť k týmto zdrojom zníži semafor čo má za následok bloknutie procesu 2, ktorý musí počkať na zvýšenie počítadlo. Proces 1 v prípade že bude opúšťať kritickú oblasť zvýši počítadlo semaforu čo zabezpečí odblokovanie procesu 1.

Semafor \textit{System V} semafory na rozdiel od \acrshort{posix} semaforov nepredstavujú len jedno počítadlo ale skupiny počítadiel. Každé jedno počítadlo môže chrániť nejakú kritickú oblasť a teda jeden \textit{System V} semafor môže chrániť viacero kritických oblastí. Veľkou výhodou je taktiež schopnosť navrátiť operácie vykonané na semafore v prípade, že proces, ktorý bol v kritickej oblasti neočakávane skončí a zabezpečiť tak aby čakajúci proces mohol vstúpiť do kritickej oblasti. 

V nasledujúcich odsekoch si popíšeme interné štruktúry v jadre Linuxu, ktoré zabezpečujú fungovanie semaforov a taktiež aj použitie tohto \acrshort{ipc} mechanizmu.
\subsubsection{Štruktúry semaforov}
Základná štruktúra, ktorá v sebe nesie hodnotu jedného počítadla má nasledovné položky:
\begin{itemize}
\item \texttt{semval} hodnota počítadla
\item \texttt{semval} \acrshort{pid} procesu, ktorý posledný modifikoval semafor
\item \texttt{lock} uzamykací mechanizmus pre ochranu počítadla
\item \texttt{pending\_alter} a \texttt{pending\_const} operácie, ktoré čakajú na vykonanie
\item \texttt{sem\_otime} čas posledného volania funkcie \texttt{sem\_op} nad počítadlom
\end{itemize}
Nadradenou štruktúrou, ktorá predstavuje skupiny počítadiel je \texttt{sem\_array}, ktorá má nasledovné položky:
\begin{itemize}
\item \texttt{sem\_perm} štruktúra typu \texttt{kern\_ipc\_perm}, ktorú sme si popísali v kapitole \ref{kernipcperm}
\item \texttt{sem\_ctime} čas posledného volania funkcie \texttt{sem\_ctl} nad semaforom
\item \texttt{pending\_alter} a \texttt{pending\_const} operácie, ktoré čakajú na vykonanie
\item \texttt{list\_id} spätné operácie na celú skupinu semaforov, ide o vlastnosť, ktorú sme si popísali v úvode do kapitoly
\item \texttt{sem\_nsems} počet semaforov
\item \texttt{complex\_count} počet komplexných operácii ktoré čakajú na vykonanie
\item \texttt{use\_global\_lock} globálny uzamykací mechanizmus nad celou skupinou semaforov
\item \texttt{\textbf{sems}} pole jednotlivých semaforov/počítadiel
\end{itemize}
Operácie, ktoré sa nad týmito semaformi vykonávajú sú uložené v štruktúre \texttt{sem\_queue}. Ide o zreťazený zoznam a každá jedna inštancia tejto štruktúry predstavuje operácie jedného procesu, ktorý je blokovaný(spí) na semafore. Táto štruktúra vyzerá nasledovne:
\begin{itemize}
\item \texttt{list} ďalšie položky zreťazeného zoznamu
\item \texttt{sleeper} štruktúra typu \texttt{task\_struct}, teda proces, ktorý spí
\item \texttt{undo} spätné operácie
\item \texttt{sops} pole štruktúr typu \texttt{sembuf}, ktoré definuje nevykonané operácie
\item \texttt{blocking} pole štruktúr typu \texttt{sembuf}, ktoré definuje operácie ktoré sú blokovacie
\item \texttt{nsops} počet operácií
\item \texttt{alter} príznak, ktorý označuje či operácia modifikuje pole semaforov
\item \texttt{dupsop} TODO príznak, ktorý označuje či operácia modifikuje pole semaforov
\end{itemize}
Štruktúry na prácu s operáciami, ktoré majú byť v prípade ukončenia programu obnovené do pôvodného stavu sú štruktúry \texttt{sem\_undo} a \texttt{sem\_undo\_list}. Každý proces má jednu prislúchajúcu štruktúru \texttt{sem\_undo} a v prípade že je proces ukončený tak sa tieto operácie vykonajú. Štruktúra \texttt{sem\_undo\_list} zabezpečuje zdieľaný prístup k \texttt{sem\_undo} štruktúram v prípade že viacero procesov zdieľa jeden list čo je možné zabezpečiť pomocou príznaku \texttt{CLONE\_SYSVSEM} pri vytváraní nového procesu.
\subsubsection{Použitie semaforov} \label{smaforuse}
\textit{System V} semafor sa vytvára pomocou systémového volania \texttt{semget}, ktoré je analogické k funkcii \texttt{msgget}, ktorú sme si popísali v kapitole \ref{msguse}. JEdiným rozdielom je parameter \textbf{\texttt{nsems}}, ktorý definuje koľko jednotlivých semaforov chceme vytvoriť.
Takto vytvorený semafor je možné používať a vykonávať nad ním operácie pomocou systémového volania \texttt{semop}, ktoré má nasledovné parametre:
\begin{itemize}
\item \texttt{semid} identiifkátor semaforu
\item \texttt{sops} operácie nad semaforom
\item \texttt{nsops} počet operácii v poli
\end{itemize}
Jednotlivé operácie sú definované pomocou štruktúry \texttt{sembuf}, ktorá má nasledujúce položky:
\begin{itemize}
\item \texttt{sem\_num} číslo semaforu nad ktorým chcem operáciu vykonať
\item \texttt{sem\_op} typ operácie
\item \texttt{sem\_flg} príznaky operácie
\end{itemize}
\texttt{sem\_flg} môže nadobúdať dve hodnoty, ktoré sú \texttt{SEM\_UNDO} a \texttt{IPC\_NOWAIT}. \texttt{SEM\_UNDO} indikuje že chceme aby daná operácia bola obnoviteľná. Príznak \texttt{IPC\_NOWAIT} priamo súvisí s parametrom \texttt{sem\_op}, ktorý môže nadobudnúť tieto stavy:
\begin{itemize}
\item \texttt{sem\_op} > 0 hodnota \texttt{sem\_op} sa pričíta k hodnota počítadla(vyžaduje sa právo na zápis)
\item \texttt{sem\_op} == 0 a \texttt{semval} == 0 tak operácia okamžite prebehne, inak ak je definovaný príznak \texttt{IPC\_NOWAIT} operácie skončí s chybou ak však tento príznak nieje definovaný proces čaká pokiaľ bude semafor 0(vyžaduje práva na čítanie semaforu)
\item \texttt{sem\_op} < 0 a zároveň \texttt{semval} >= \texttt{sem\_op} tak je operácia vykonaná okamžite, inak analogicky k predošlému prípadu operácia skončí buď s chybou alebo proces čaká pokiaľ bude zvýšená hodnota počítadla(vyžaduje sa právo na zápis)
\end{itemize}
Posledným systémovým volaním je \texttt{semctl}, ktoré rovnako ako systémové volanie \texttt{msgctl} z kapitoly \ref{msguse} získava alebo zapisuje informácie o \acrshort{ipc} objekte avšak s rozdielom že využíva odlišnú štruktúru na ukladanie dát. \texttt{semctl} má nasledovné argument:
\begin{itemize}
\item \texttt{semid} identifikátor objektu
\item \texttt{semnum} index semaforu v skupine semaforov
\item \texttt{cmd} typ operácie
\item \texttt{arg} posledný argument je voliteľný podľa typu operácie, ide o union, ktorý je definovaný na ukážke kódu \ref{lst:semun}
\end{itemize}
Typy operácii, ktoré sme si definovali pri \texttt{msgctl} taktiež existujú aj pri semafóroch a zachovávajú rovnakú funkcionalitu ale výsledok týchto operácií sa ukladá do položky \texttt{arg.buf}, ktorá je typu \texttt{semid\_ds}(viď \ref{lst:semid}) pre 32 bitové systéme alebo \texttt{semid64\_ds}(viď \ref{lst:semid64}) pre 64 bitové systémy. Toto systémové volanie umožňuje aj semaforovo špecifické operácie, ktoré sú nasledovné:
\begin{itemize}
\item \texttt{GETALL}/\texttt{SETALL} vráti/nastaví hodnotu každého počítadla v skupine semaforov a uloží ho do položky \texttt{arg.array}, parameter \texttt{semnum} je ignorovaný
\item \texttt{GETNCNT}/\texttt{GETZCNT} vráti počet procesov, ktoré čakajú na zvýšenie(\texttt{GETNCNT}) alebo zníženie(\texttt{GETZCNT}) konkrétneho počítadla, ktoré je definované argumentom \texttt{semnum}
\item \texttt{GETPID} vráti PID procesu, ktorý posledný vykonal operáciu nad počítadlom, ktoré je definované argumentom \texttt{semnum}
\item \texttt{GETVAL} vráti hodnotu jedného konkrétneho počítadla definovaného pomocou \texttt{semnum}
\item \texttt{SETVAL} nastaví hodnotu, ktorá je v položke \texttt{arg.val}, jedného konkrétneho počítadla definovaného pomocou \texttt{semnum}
\end{itemize}
\subsection{Zdieľaná pamäť}
Zdieľaná pamäť predstavuje užitočný mechanizmus, ktorý umožňuje dvom alebo viacerým procesom pristupovať k spoločným dátovým štruktúram, ktoré sú uložené v oblasti zdieľanej pamäte \acrshort{ipc}.\cite{linux} Proces, ktorý chce takúto zdieľanú pamäť používať potrebuje namapovať túto pamäť na adresný priestor procesu. Následne túto pamäť môže používať akoby lokálnu pamäť, čo nevyžaduje prepínanie do módu jadra a preto tento \acrshort{ipc} mechanizmus patrí medzi najrýchlejšie.\cite{newlinux}
\subsubsection{Štruktúry zdieľanej pamäte}
Hlavnou štruktúrou, ktorá má informácie o objektoch zdieľanej pamäte je \texttt{shmid\_kernel}, ktorej položky sú nasledovné:
\begin{itemize}
\item \texttt{shm\_perm} štruktúra typu \texttt{kern\_ipc\_perm}, ktorú sme si popísali v kapitole \ref{kernipcperm}
\item \texttt{shm\_file} pointer na štruktúru \texttt{file}, ktorá predstavuje zdieľaný pamäťoví priestor
\item \texttt{shm\_nattch} počet procesov, ktoré sú \textit{pripojené} k zdieľanej pamäti
\item \texttt{shm\_segsz} veľkosť pamäťového segmentu
\item \texttt{shm\_atim}/\texttt{shm\_dtim}/\texttt{shm\_ctim} sú posledné časy prístupu/odpojenia/zmeny
\item \texttt{shm\_cprid} \acrshort{pid} procesu, ktorý vytvoril objekt
\item \texttt{shm\_lprid} \acrshort{pid} procesu, ktorý posledný pristupoval ku objektu
\item \texttt{mlock\_user} ukazovateľ na štruktúru \texttt{user\_struct}, ktorá definuje používateľa, ktorý zamkol zdieľanú pamäť v \acrshort{ram}\footnote{pre viac info pozri \url{http://man7.org/linux/man-pages/man2/mlock.2.html}}
\item \texttt{shm\_creator} ukazovateľ na štruktúru \texttt{task\_struct}, ktorý definuje proces, ktorý vytvoril zdieľanú pamäť(NULL v prípade že bol proces ukončený)
\item \texttt{shm\_clist} zoznam štruktúr \texttt{shmid\_kernel}, ktoré majú rovnaký proces, ktorý ich vytvoril
\end{itemize}
Najdôležitejšou položkou je \texttt{shm\_file}, ktorá predstavuje samotnú zdieľanú pamäť a keďže ide o súbor, môžeme vidieť blízke prepojenie s Linux \acrshort{vfs}. Avšak nejde o normálny súbor a nie je možné ho nájsť v strome súborového systému, pretože sa využíva špeciálny \textit{shm} súborový systém.\cite{linux} Preto ak proces chce zapisovať alebo čítať z tohoto pamäťového segmentu je potrebne aby sa pripojil. Ako na to sa dozvieme v kapitole \ref{shmuse}.
\subsubsection{Požitie zdieľanej pamäte} \label{shmuse}
Zdieľanú pamäť podobne ako ostatne \textit{System V} mechanizmy je možné vytvoriť pomocou systémového volania \texttt{shmget}. Toto systémové volanie sa líši v argumente \texttt{size}, ktorý určuje akú veľkú pamäť chceme alokovať, pričom táto pamäť je zaokrúhlená nahor k najbližšiemu násobku \texttt{PAGE\_SIZE}. Jedným z rozdielov je taktiež možnosť definovať príznaky \texttt{SHM\_HUGETLB}, \texttt{SHM\_HUGE\_2MB} a \texttt{SHM\_HUGE\_1GB}, ktoré signalizujú alokáciu s použitím \textit{huge pages}\footnote{Pre viac info pozri \url{https://elixir.bootlin.com/linux/latest/source/Documentation/vm/hugetlbpage.txt}}. Posledný z príznakov je \texttt{SHM\_NORESERVE}, ktorý definuje že sa nemá rezervovať \textit{swap} pamäť.

Nad takto vytvorenou zdieľanou pamäťou je možné robiť dve operácie \texttt{shmat} a \texttt{shmdt}. \texttt{shmat} pripojí zdieľanú pamäť do adresného priestoru procesu, argumenty sú nasledovné:
\begin{itemize}
\item \texttt{shmid} identifikátor zdieľanej pamäte
\item \texttt{shmaddr} adresa na ktorú sa zdieľaná pamäť pripojí, môže nadobudnúť nasledovné hodnoty:
\begin{itemize}
\item \texttt{NULL} systém sám vyberie najvhodnejšiu nepoužívanú adresu
\item rôzna od \texttt{NULL} a zároveň je definovaný príznak \texttt{SMH\_RND} tak pamäť je pripojená a zarovnaná dole na najbližší násobok  \texttt{SHMLBA}\footnote{Táto hodnota je zväčša násobok \texttt{PAGE\_SIZE} a na väčšine Linuxových architektúrach je rovnaká ako \texttt{PAGE\_SIZE}} ak však príznak nie je definovaný adresa musí byť zarovnaná na násobok \texttt{PAGE\_SIZE} a následne môže byť pamäť pripojená
\end{itemize}
\item \texttt{shmflg} môže nadobudnúť nasledovné hodnoty
\begin{itemize}
\item \texttt{SHM\_EXEC} povoľuje spúšťanie obsahu, ktorý sa nachádza v zdieľanej pamäti 
\item \texttt{SHM\_RDONLY} pripojí proces len s prístupom na čítanie, ak príznak nie je definovaný proces sa bude pripájať s prístupom na čítanie a zápis avšak \textbf{proces musí mať práva na čítanie a zápis} 
\item \texttt{SHM\_REMAP} príznak povoľuje prepísanie existujúceho mapovania, \texttt{shmaddr} nesmie byť \texttt{NULL}
\end{itemize}
\end{itemize}
Po úspešnom pripojení funkcia \texttt{shmat} vracia adresu pripojenej pamäte v opačnom prípade \texttt{(void *) -1}. 

Na odpojenie od zdieľanej pamäte sa používa funkcia \texttt{shmdt}, ktorá má jeden argument \texttt{shmaddr}, ktorý definuje adresu na ktorej je zdieľaná pamäť pripojená. Táto funkcia vracia 0 v prípade úspechu, inak vracia -1.

Posledným systémovým volaním je \texttt{shmctl}, ktoré pracuje analogicky k systémovému volaniu \texttt{msgctl} o ktorom sa môžete viac dočítať v závere kapitoly \ref{msguse}. \texttt{shmctl} poskytuje na rozdiel od \texttt{msgctl} 2 príznaky, ktoré sú \texttt{SHM\_LOCK} a \texttt{SHM\_UNLOCK}. Tieto príznaky povoľujú alebo zabraňujú \textit{swapovaniu} zdieľanej pamäte. \texttt{SHM\_UNLOCK} definuje, že napríklad v situáciu veľkého vyťaženia pamäte môže \textit{swap} pamäte.\cite{shmctl}

Na prácu so zdieľanou pamäťou teda zapisovanie a čítanie z pamäte používame rovnaké nástroje ako na prácu s bežným súborom a teda na zapisovanie môžeme použiť napríklad \texttt{fprintf} a na čítanie \texttt{putchar}.
\subsection{Sokety}

\section{Medusa}
Medusa je bezpečnostný systém pre jadro Linux-u.

\section{Úkážka glossaries}
\noindent Verzia FEIstyle 1.5 používa glossary\footnote{\url{https://www.ctan.org/pkg/glossaries?lang=en}} balík.
\acrfull{cdma} je dlhá skratka naopak \acrshort{gsm} je skratka v krátkej forme.
\section{Recitácia}
Citujem všetky zdroje v \textbf{bibliography.bib}, \cite{t00, t01, t02, t03, kniha, kniha2, kniha3, small, big, cs, koll, kap, tug, knuth, zbornik, prispevok}. \newline Good luck.
\section{Možnosti anonymizácie}
\noindent Anonymizácia znamená zmena alebo úprava údajov tak, aby sa podľa nich nedala jednoznačne určiť osoba, ktorej tieto údaje patria \cite{t01}. Existuje niekoľko spôsobov, ktorými môžeme dosiahnuť rôznu úroveň anonymizácie na internete: od mazania cookies súborov po ukončení prehliadania webových stránok až po používanie operačných systémov, ktoré sú na anonymite založené; od bezplatných možností až po komerčné verzie.  
\newline Nasleduje priblíženie niektorých možnosti anonymizácie.

\subsection{Súkromné prehliadanie}
\noindent Najpoužívanejšie internetové prehliadače súčasnosti majú v sebe zabudovanú funkcionalitu, ktorá dokáže čiastočne anonymizovať prístup na internet. Táto funkcionalita blokuje ukladanie navštívených stránok do histórie a nezaznamenáva súbory, ktoré sa stiahnu z~internetu. \acrshort{sw} a \acrlong{hw} sú skratky.

\begin{table}[!htbp]
\caption{Moduly a ich funkcie pri anonymizácii}
\label{modulyVlastnosti}
\begin{center}
\begin{tabular}{p{4cm}|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c}
& \multicolumn{14}{c}%
	 {\textbf{Funkcia}}\\ \hline
&&&& & &\multicolumn{8}{c}%
	 {Modifikácia}\\ 
\textbf{Modul} &\begin{sideways} zobrazenie hlavičky \end{sideways} &\begin{sideways} blokovanie skriptov \end{sideways} &\begin{sideways} zmena IP \end{sideways} & \begin{sideways} zmena lokalizácie \end{sideways} & \begin{sideways} zmazanie/blokovanie cookies \end{sideways} & \begin{sideways} blokovanie trackerov \end{sideways}  & \begin{sideways} popis \end{sideways} & \begin{sideways}používateľský agent\end{sideways} & \begin{sideways} kódové označenie prehliadača \end{sideways} & \begin{sideways} názov prehliadača \end{sideways} & \begin{sideways} verzia prehliadača \end{sideways} & \begin{sideways} platforma \end{sideways} & \begin{sideways} výrobca prehliadača \end{sideways} & \begin{sideways} označenie výrobcu prehliadača \end{sideways} \\ \hline
User agent switcher & & & & & &  & X & X & X & X & X & X & X & X  \\ \hline
Ghostery &  && & & X & X &  &  & & & & & & \\  \hline
Better privacy && &  & & X &  &  &  & & & & & & \\  \hline
Anonymox &  && X & X & X &  & X & X & & & & & & \\  \hline
Modify headers & & &  &  & X &  &  & X &  &  &  & & &  \\  \hline
Request policy & & &  &  & & X  &  &  &  &  &  & & &   \\  \hline
Live HTTP headers & X& &  &  & &  &  &  &  &  &  & & &   \\  \hline
User agent awitcher for chrome & & &  &  & &  & X & X &  &  &  & & &   \\  \hline
Header hacker & & &  &  & &  & X & X & X & X & X & X & X & X    \\  \hline
Mod header & & &  &  & &  & X & X & X & X & X & X & X & X    \\  \hline
Script no & &X &  &  & &  &  &  &  &  &  &  &  &     \\  \hline
No script & &X &  &  & &  &  &  &  &  &  &  &  &     \\  \hline
Proxify it & & &X  & X & &  &  &  &  &  &  &  &  &     \\  \hline
I'm not here & & &  & X & &  &  &  &  &  &  &  &  &     \\  \hline
Get anonymous personal edition & &X &X &X &X&X &  &  &  &  &  &  &  &     \\  \hline
Anonymous browsing toolbar & & & X & X & &  &  &  &  &  &  &  &  &     \\  \hline
Easy hide your IP and surf anonymously & & & X & X& &  &  & X & X & X & X &  &  &     \\  \hline
\end{tabular}
\end{center}
\end{table}

\subsection{Anonymná sieť}
\noindent Anonymná sieť je sieť serverov, medzi ktorými dáta prechádzajú šifrované. V anonymných sieťach dáta prechádzajú z počítača používateľa, odkiaľ bola požiadavka poslaná, cez viaceré proxy smerovače, z ktorých každý správu doplní o smerovanie a zašifruje vlastným kľúčom. Cesta od ...


\subsection{Funkcionalita}
\noindent  Rozšírenie tiež okrem splnenia špecifikácie malo pre prehľadnosť a overenie funkčnosti zobrazovať údaje, ktoré boli na server odoslané. Zoznam údajov odoslaných na server, sa mal ukladať do krátkodobej histórie, aby nemal používateľ k dispozícií len najnovšie údaje, ale aj údaje odoslané v nejakom časovom období. Nejaky listing z priloh \ref{lst:sublime}.

\subsubsection{Funkcionalita2}
\noindent Samozrejmosťou bolo nastavenie zapnutia rozšírenia pri štarte, prípadne interval zmeny odosielaných údajov.

\subsection{Vzhľad}
\noindent Dôležitou požiadavkou kladenou na rozšírenie bolo príjemné používateľské rozhranie. Z~tohto dôvodu malo rozšírenie obsahovať zoznam modifikovaných vlastností a tlačidlo pre prístup k nastaveniam rozšírenia v jednoduchej a praktickej forme. Predpokladaný vzhľad je zobrazený na obrázku č. \ref{vzhladobr}.
\begin{figure}[!htbp]
  \centering
  \includegraphics[width=8cm]{img/vzhlad.png}
  \caption{Predpokladaný vzhľad rozšírenia.}
  \label{vzhladobr}
\end{figure}	 
\noindent Dôležitou požiadavkou kladenou na rozšírenie bolo príjemné používateľské rozhranie.\cite{t00} Z~tohto dôvodu malo rozšírenie obsahovať zoznam modifikovaných vlastností a tlačidlo pre prístup k nastaveniam rozšírenia v jednoduchej a praktickej forme. Predpokladaný vzhľad je zobrazený na obrázku č. \ref{vzhladobr}.

\begin{algorithm}
\scriptsize
\begin{algorithmic}
 \STATE <text>
 \IF{<condition>} \STATE {<text>} \ELSE \STATE{<text>} \ENDIF
 \IF{<condition>} \STATE {<text>} \ELSIF{<condition>} \STATE{<text>} \ENDIF
 \FOR{<condition>} \STATE {<text>} \ENDFOR
 \FOR{<condition> \TO <condition> } \STATE {<text>} \ENDFOR
 \FORALL{<condition>} \STATE{<text>} \ENDFOR
 \WHILE{<condition>} \STATE{<text>} \ENDWHILE
 \REPEAT \STATE{<text>} \UNTIL{<condition>}
 \LOOP \STATE{<text>} \ENDLOOP
 \REQUIRE <text>
 \ENSURE <text>
 \RETURN <text>
 \PRINT <text>
 \COMMENT{<text>}
 \AND, \OR, \XOR, \NOT, \TO, \TRUE, \FALSE
\end{algorithmic}
\caption{Ukážka príkazov pre algorithmic}  
\label{alg:preview}  
\end{algorithm}

\begin{lstlisting}[
  caption={Ukážka algoritmu},
  label={lst:main-c},
  language=c
]
/* Hello World program */

#include<stdio.h>

struct cpu_info {
    long unsigned utime, ntime, stime, itime;
    long unsigned iowtime, irqtime, sirqtime;
};

main()
{
    printf("Hello World");
}
\end{lstlisting}
